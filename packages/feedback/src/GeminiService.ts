import axios from 'axios';
import dotenv from 'dotenv';
import fs from 'fs/promises';
import { APIResilience } from '@cli-ai-toolkit/utils';

dotenv.config();

export interface ImageComparisonResult {
    pass: boolean;
    score: number;
    notes: string;
}

export interface UICritiqueItem {
    priority: 'critical' | 'high' | 'medium' | 'low';
    category: 'layout' | 'typography' | 'colors' | 'spacing' | 'sizing' | 'alignment' | 'borders' | 'other';
    element: string; // Specific UI element (e.g., "Header navigation", "Primary button")
    issue: string; // What's wrong
    expected: string; // What it should be
    actual: string; // What it currently is
}

export interface UICritique {
    items: UICritiqueItem[];
    summary: string;
    totalIssues: number;
}

export interface UICritiqueItem {
    priority: 'critical' | 'high' | 'medium' | 'low';
    category: 'layout' | 'typography' | 'colors' | 'spacing' | 'sizing' | 'alignment' | 'borders' | 'other';
    element: string; // Specific UI element (e.g., "Header navigation", "Primary button")
    issue: string; // What's wrong
    expected: string; // What it should be
    actual: string; // What it currently is
}

export interface UICritique {
    items: UICritiqueItem[];
    summary: string;
    totalIssues: number;
}

export class GeminiService {
    private apiKey: string;
    private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models';

    constructor() {
        const apiKey = process.env.GEMINI_API_KEY;
        if (!apiKey) {
            throw new Error('GEMINI_API_KEY is missing in .env');
        }
        this.apiKey = apiKey;
    }

    async generateContent(prompt: string): Promise<string> {
        return APIResilience.executeWithRetry(
            async () => {
                const url = `${this.baseUrl}/gemini-2.0-flash-lite:generateContent?key=${this.apiKey}`;

                const response = await axios.post(
                    url,
                    {
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }]
                    },
                    {
                        timeout: 45000, // 45 second timeout for Gemini
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }
                );

                const content = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!content) {
                    throw new Error('No response generated by Gemini API');
                }
                
                return content;
            },
            { maxRetries: 2, timeoutMs: 50000 },
            'Gemini API'
        );
    }

    /**
     * Compare two images based on a goal/criteria
     * @param goal - The evaluation criteria
     * @param targetImagePath - Path to the target/reference image
     * @param candidateImagePath - Path to the candidate image to evaluate
     * @returns Comparison result with pass/fail, score, and notes
     */
    async compareImages(
        goal: string,
        targetImagePath: string,
        candidateImagePath: string
    ): Promise<ImageComparisonResult> {
        return APIResilience.executeWithRetry(
            async () => {
                // Read and encode images as base64
                const targetBuffer = await fs.readFile(targetImagePath);
                const candidateBuffer = await fs.readFile(candidateImagePath);
                
                const targetBase64 = targetBuffer.toString('base64');
                const candidateBase64 = candidateBuffer.toString('base64');

                // Determine MIME type (assume PNG/JPEG)
                const targetMime = targetImagePath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
                const candidateMime = candidateImagePath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';

                const url = `${this.baseUrl}/gemini-2.0-flash-lite:generateContent?key=${this.apiKey}`;

                const prompt = `ROLE

You are a strict visual quality judge and art director.

You NEVER generate code.
You NEVER modify files.
You ONLY evaluate and critique.

You analyze images and screenshots and determine:
- correctness
- quality
- similarity
- completeness
- visual accuracy

---

TASK

Evaluate the provided images.

Image A (TARGET):
The reference / expected output
[First image]

Image B (CANDIDATE):
The generated output to evaluate
[Second image]

GOAL: ${goal}

Determine how closely Image B matches Image A.

---

EVALUATION CRITERIA

Analyze:
- Layout structure
- Spacing and alignment  
- Typography (font size, weight, style)
- Color accuracy
- Component shapes
- Padding and margins
- Image placement
- Overall visual hierarchy

---

OUTPUT FORMAT

Return ONLY valid JSON (no markdown, no code blocks):
{
  "score": <number 0-100>,
  "pass": <boolean>,
  "notes": "short overall assessment"
}

---

SCORING RULES

100 = visually identical
90+ = nearly identical
70–89 = recognizable but flawed
50–69 = significant errors
below 50 = poor match

pass = true only if score >= 85

---

CRITICAL RULE

You do NOT generate code.
You ONLY describe what must be fixed.
You are a judge, not a builder.`;

                const response = await axios.post(
                    url,
                    {
                        contents: [{
                            parts: [
                                { text: prompt },
                                {
                                    inline_data: {
                                        mime_type: targetMime,
                                        data: targetBase64
                                    }
                                },
                                {
                                    inline_data: {
                                        mime_type: candidateMime,
                                        data: candidateBase64
                                    }
                                }
                            ]
                        }]
                    },
                    {
                        timeout: 60000, // 60 second timeout for vision tasks
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }
                );

                const content = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!content) {
                    throw new Error('No response generated by Gemini Vision API');
                }

                // Parse JSON response
                const cleaned = content.trim().replace(/```json\s*/g, '').replace(/```\s*/g, '');
                const result = JSON.parse(cleaned);

                return {
                    pass: result.pass === true,
                    score: Number(result.score) || 0,
                    notes: result.notes || 'No notes provided'
                };
            },
            { maxRetries: 2, timeoutMs: 70000 },
            'Gemini Vision API'
        );
    }

    /**
     * Generate detailed UI critique comparing two screenshots
     * Produces a prioritized punch list of concrete UI differences
     * @param targetImagePath - Path to the target/reference image
     * @param candidateImagePath - Path to the candidate image
     * @param context - Optional context about what's being compared
     * @returns Detailed UI critique with actionable items
     */
    async generateUICritique(
        targetImagePath: string,
        candidateImagePath: string,
        context?: string
    ): Promise<UICritique> {
        return APIResilience.executeWithRetry(
            async () => {
                // Read and encode images as base64
                const targetBuffer = await fs.readFile(targetImagePath);
                const candidateBuffer = await fs.readFile(candidateImagePath);
                
                const targetBase64 = targetBuffer.toString('base64');
                const candidateBase64 = candidateBuffer.toString('base64');

                // Determine MIME type
                const targetMime = targetImagePath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
                const candidateMime = candidateImagePath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';

                const url = `${this.baseUrl}/gemini-2.0-flash-lite:generateContent?key=${this.apiKey}`;

                const prompt = `ROLE

You are a strict visual quality judge and UI/UX art director.

You NEVER generate code.
You NEVER modify files.
You ONLY evaluate and critique.

You analyze screenshots and determine:
- visual accuracy
- layout correctness
- typography precision
- color matching
- spacing consistency

---

TASK

Evaluate the provided screenshots.

Image A (TARGET):
The reference / expected UI
[First image]

Image B (CANDIDATE):
The generated UI to evaluate
[Second image]
${context ? `\nCONTEXT: ${context}` : ''}

Identify 5-10 CONCRETE, ACTIONABLE UI differences.

---

EVALUATION CRITERIA

Analyze:
- Layout: positioning, margins, padding, spacing
- Typography: font family, size, weight, line-height, letter-spacing
- Colors: hex values, opacity, gradients
- Sizing: width, height, dimensions of elements
- Alignment: horizontal/vertical alignment issues
- Borders: radius, width, color, style
- Specific measurements where possible

---

OUTPUT FORMAT

Return ONLY valid JSON (no markdown, no code blocks):
{
  "summary": "Brief 1-2 sentence overview",
  "items": [
    {
      "priority": "critical|high|medium|low",
      "category": "layout|typography|colors|spacing|sizing|alignment|borders|other",
      "element": "Specific UI element name",
      "issue": "What's wrong",
      "expected": "What target shows (be specific)",
      "actual": "What candidate shows (be specific)"
    }
  ]
}

---

PRIORITY RULES

critical: breaks layout or makes UI unusable
high: very noticeable, affects user experience
medium: noticeable but minor impact
low: subtle difference, minimal impact

---

CRITICAL RULE

You do NOT generate code.
You ONLY describe what must be fixed.
The coding agent will use your instructions.
You are a judge, not a builder.`;

                const response = await axios.post(
                    url,
                    {
                        contents: [{
                            parts: [
                                { text: prompt },
                                {
                                    inline_data: {
                                        mime_type: targetMime,
                                        data: targetBase64
                                    }
                                },
                                {
                                    inline_data: {
                                        mime_type: candidateMime,
                                        data: candidateBase64
                                    }
                                }
                            ]
                        }]
                    },
                    {
                        timeout: 60000,
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }
                );

                const content = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!content) {
                    throw new Error('No response generated by Gemini Vision API');
                }

                // Parse JSON response
                const cleaned = content.trim().replace(/```json\s*/g, '').replace(/```\s*/g, '');
                const result = JSON.parse(cleaned);

                return {
                    items: result.items || [],
                    summary: result.summary || 'No summary provided',
                    totalIssues: (result.items || []).length
                };
            },
            { maxRetries: 2, timeoutMs: 70000 },
            'Gemini Vision API (UI Critique)'
        );
    }

    /**
     * Generate HTML/CSS code from a screenshot
     * @param screenshotPath - Path to the screenshot image
     * @param additionalContext - Optional context or revision notes
     * @returns Complete HTML with embedded CSS
     */
    async generateHTMLFromScreenshot(
        screenshotPath: string,
        additionalContext?: string
    ): Promise<string> {
        return APIResilience.executeWithRetry(
            async () => {
                // Read and encode image as base64
                const imageBuffer = await fs.readFile(screenshotPath);
                const imageBase64 = imageBuffer.toString('base64');

                // Determine MIME type
                const imageMime = screenshotPath.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';

                const url = `${this.baseUrl}/gemini-2.0-flash-lite:generateContent?key=${this.apiKey}`;

                const basePrompt = `You are an expert web developer. Analyze this screenshot and recreate it as a complete, standalone HTML page with embedded CSS.

REQUIREMENTS:
1. Create a SINGLE HTML file with all CSS embedded in <style> tags
2. Match the layout, colors, typography, spacing, and styling EXACTLY
3. Use semantic HTML5 elements
4. Make it responsive and pixel-perfect
5. Include all visible text, buttons, images (use placeholder images if needed)
6. Use modern CSS (flexbox/grid where appropriate)
7. Match fonts as closely as possible (use web-safe fonts or Google Fonts)
8. Pay attention to: padding, margins, colors (exact hex values), font sizes, borders, shadows

${additionalContext ? `\nREVISION NOTES:\n${additionalContext}\n\nAddress these issues in your implementation.` : ''}

Output ONLY the complete HTML code. Do NOT include markdown code blocks or explanations. Start with <!DOCTYPE html>`;

                const response = await axios.post(
                    url,
                    {
                        contents: [{
                            parts: [
                                { text: basePrompt },
                                {
                                    inline_data: {
                                        mime_type: imageMime,
                                        data: imageBase64
                                    }
                                }
                            ]
                        }]
                    },
                    {
                        timeout: 90000, // 90 seconds for complex generation
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    }
                );

                const content = response.data?.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!content) {
                    throw new Error('No response generated by Gemini Vision API');
                }

                // Clean up markdown code blocks if present
                let cleaned = content.trim();
                cleaned = cleaned.replace(/^```html\s*/m, '');
                cleaned = cleaned.replace(/^```\s*/m, '');
                cleaned = cleaned.replace(/```\s*$/m, '');
                cleaned = cleaned.trim();

                // Validate it looks like HTML
                if (!cleaned.toLowerCase().includes('<!doctype html') && !cleaned.toLowerCase().includes('<html')) {
                    throw new Error('Generated content does not appear to be valid HTML');
                }

                return cleaned;
            },
            { maxRetries: 2, timeoutMs: 100000 },
            'Gemini Vision API (HTML Generation)'
        );
    }
}
